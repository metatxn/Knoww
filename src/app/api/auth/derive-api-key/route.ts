import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";

/**
 * Schema for L1 authentication headers
 * These are generated by signing an EIP-712 message on the frontend
 */
const l1AuthSchema = z.object({
  address: z.string().describe("User's Polygon address"),
  signature: z.string().describe("EIP-712 signature"),
  timestamp: z.string().describe("UNIX timestamp used in signature"),
  nonce: z.string().optional().default("0").describe("Nonce used in signature"),
});

/**
 * L1 Headers for Polymarket API authentication
 */
interface L1Headers {
  POLY_ADDRESS: string;
  POLY_SIGNATURE: string;
  POLY_TIMESTAMP: string;
  POLY_NONCE: string;
}

/**
 * API Key response from Polymarket
 */
interface ApiKeyResponse {
  error?: string;
  apiKey?: string;
  secret?: string;
  passphrase?: string;
}

/**
 * Create a new API key for a first-time user
 * POST /auth/api-key
 */
async function createApiKey(
  clobHost: string,
  headers: L1Headers
): Promise<{ success: boolean; data?: ApiKeyResponse; error?: string }> {
  console.log("[api-key] Attempting to CREATE new API key...");

  const response = await fetch(`${clobHost}/auth/api-key`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...headers,
    },
  });

  const responseText = await response.text();
  console.log("[api-key] Create response:", {
    status: response.status,
    body: responseText,
  });

  try {
    const data = JSON.parse(responseText) as ApiKeyResponse;

    if (response.ok && data.apiKey) {
      return { success: true, data };
    }

    return { success: false, error: data.error || responseText };
  } catch {
    return { success: false, error: responseText };
  }
}

/**
 * Derive (retrieve) an existing API key
 * GET /auth/derive-api-key
 */
async function deriveApiKey(
  clobHost: string,
  headers: L1Headers
): Promise<{ success: boolean; data?: ApiKeyResponse; error?: string }> {
  console.log("[api-key] Attempting to DERIVE existing API key...");

  const response = await fetch(`${clobHost}/auth/derive-api-key`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      ...headers,
    },
  });

  const responseText = await response.text();
  console.log("[api-key] Derive response:", {
    status: response.status,
    body: responseText,
  });

  try {
    const data = JSON.parse(responseText) as ApiKeyResponse;

    if (response.ok && data.apiKey) {
      return { success: true, data };
    }

    return { success: false, error: data.error || responseText };
  } catch {
    return { success: false, error: responseText };
  }
}

/**
 * POST /api/auth/derive-api-key
 *
 * Create or derive API key credentials for a user using their L1 authentication.
 * This endpoint implements the "createOrDeriveApiKey" pattern:
 *
 * 1. First, try to CREATE a new API key (for first-time users)
 * 2. If creation fails (key already exists), DERIVE the existing key
 *
 * This ensures:
 * - New users get their API key created
 * - Returning users get their existing API key derived
 *
 * Flow:
 * 1. Frontend signs EIP-712 ClobAuth message
 * 2. Frontend sends signature + metadata to this endpoint
 * 3. Backend tries POST /auth/api-key (create)
 * 4. If fails, backend tries GET /auth/derive-api-key (derive)
 * 5. Backend returns the API credentials to frontend
 * 6. Frontend stores credentials for future order submissions
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const parsed = l1AuthSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        {
          success: false,
          error: "Invalid request body",
          details: parsed.error.message,
        },
        { status: 400 }
      );
    }

    const { address, signature, timestamp, nonce } = parsed.data;

    const clobHost =
      process.env.NEXT_PUBLIC_POLYMARKET_HOST || "https://clob.polymarket.com";

    console.log("[api-key] Request:", {
      address,
      timestamp,
      nonce,
      signatureLength: signature.length,
      clobHost,
    });

    // Build L1 headers for Polymarket authentication
    const l1Headers: L1Headers = {
      POLY_ADDRESS: address,
      POLY_SIGNATURE: signature,
      POLY_TIMESTAMP: timestamp,
      POLY_NONCE: nonce,
    };

    // Step 1: Try to CREATE a new API key (for first-time users)
    const createResult = await createApiKey(clobHost, l1Headers);

    if (createResult.success && createResult.data) {
      console.log("[api-key] Successfully CREATED new API key");
      return NextResponse.json({
        success: true,
        credentials: createResult.data,
        method: "create",
      });
    }

    console.log(
      "[api-key] Create failed, attempting derive...",
      createResult.error
    );

    // Step 2: If create failed, try to DERIVE existing API key
    const deriveResult = await deriveApiKey(clobHost, l1Headers);

    if (deriveResult.success && deriveResult.data) {
      console.log("[api-key] Successfully DERIVED existing API key");
      return NextResponse.json({
        success: true,
        credentials: deriveResult.data,
        method: "derive",
      });
    }

    // Both create and derive failed
    console.error("[api-key] Both create and derive failed:", {
      createError: createResult.error,
      deriveError: deriveResult.error,
    });

    // Provide helpful error message
    let errorMessage = "Failed to create or retrieve API credentials.";

    if (
      createResult.error?.includes("not enabled") ||
      deriveResult.error?.includes("not enabled")
    ) {
      errorMessage =
        "Your wallet is not enabled for trading. Please complete the wallet setup steps first (Deploy wallet & Approve USDC).";
    } else if (
      createResult.error?.includes("signature") ||
      deriveResult.error?.includes("signature")
    ) {
      errorMessage = "Signature verification failed. Please try signing again.";
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        details: {
          createError: createResult.error,
          deriveError: deriveResult.error,
        },
      },
      { status: 400 }
    );
  } catch (error) {
    console.error("[api-key] Error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
