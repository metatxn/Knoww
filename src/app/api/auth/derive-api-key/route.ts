import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";

/**
 * Schema for L1 authentication headers
 * These are generated by signing an EIP-712 message on the frontend
 */
const l1AuthSchema = z.object({
  address: z.string().describe("User's Polygon address"),
  signature: z.string().describe("EIP-712 signature"),
  timestamp: z.string().describe("UNIX timestamp used in signature"),
  nonce: z.string().optional().default("0").describe("Nonce used in signature"),
});

/**
 * POST /api/auth/derive-api-key
 *
 * Derive API key credentials for a user using their L1 authentication.
 * This endpoint proxies the request to Polymarket's CLOB API.
 *
 * The user must sign an EIP-712 message on the frontend to generate
 * the L1 authentication headers.
 *
 * Flow:
 * 1. Frontend signs EIP-712 ClobAuth message
 * 2. Frontend sends signature + metadata to this endpoint
 * 3. Backend forwards to Polymarket CLOB /auth/derive-api-key
 * 4. Backend returns the derived API credentials to frontend
 * 5. Frontend stores credentials for future order submissions
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const parsed = l1AuthSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        {
          success: false,
          error: "Invalid request body",
          details: parsed.error.message,
        },
        { status: 400 }
      );
    }

    const { address, signature, timestamp, nonce } = parsed.data;

    const clobHost =
      process.env.NEXT_PUBLIC_POLYMARKET_HOST || "https://clob.polymarket.com";

    // Polymarket expects checksummed address (mixed case)
    // The signature is generated with the checksummed address, so we must use the same
    console.log("[derive-api-key] Request:", {
      address,
      timestamp,
      nonce,
      signatureLength: signature.length,
      clobHost,
    });

    // Call Polymarket's derive-api-key endpoint with L1 headers
    // Note: POLY_ADDRESS should match the address used in the signature (checksummed)
    const response = await fetch(`${clobHost}/auth/derive-api-key`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        POLY_ADDRESS: address, // Keep original case (checksummed)
        POLY_SIGNATURE: signature,
        POLY_TIMESTAMP: timestamp,
        POLY_NONCE: nonce,
      },
    });

    const responseText = await response.text();
    console.log("[derive-api-key] Polymarket response:", {
      status: response.status,
      statusText: response.statusText,
      body: responseText,
    });

    let data: {
      error?: string;
      apiKey?: string;
      secret?: string;
      passphrase?: string;
    };

    try {
      data = JSON.parse(responseText);
    } catch {
      return NextResponse.json(
        {
          success: false,
          error: `Invalid JSON response from Polymarket: ${responseText}`,
        },
        { status: 500 }
      );
    }

    if (!response.ok) {
      console.error("[derive-api-key] Failed:", data);
      return NextResponse.json(
        {
          success: false,
          error: data.error || `Failed to derive API key (${response.status})`,
          details: responseText,
        },
        { status: response.status }
      );
    }

    console.log("[derive-api-key] Success - credentials received");

    // Return the derived credentials
    // Note: The frontend should securely store these
    return NextResponse.json({
      success: true,
      credentials: data,
    });
  } catch (error) {
    console.error("[derive-api-key] Error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
